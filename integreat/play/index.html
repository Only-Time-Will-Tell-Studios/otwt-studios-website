<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integreat! - Calculus Roguelike</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #020617;
            color: #e2e8f0;
            overflow: hidden;
            user-select: none;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        #app-scaler {
            width: 1280px;
            height: 800px;
            position: relative;
            transform-origin: center center;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background-color: #0f172a;
            overflow: hidden;
        }

        /* Card Interactions */
        .card {
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
        }
        .card:not(.disabled):hover {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
            z-index: 50;
        }
        .card.dragging {
            opacity: 0.5;
            transform: scale(0.9);
        }
        /* Highlight for Hint Powerup */
        .card.highlight-hint {
            border-color: #facc15 !important;
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.6);
            background-color: #fefce8;
        }

        /* Slot Interactions */
        .slot { transition: all 0.2s; }
        .slot.drag-over {
            background-color: rgba(56, 189, 248, 0.2);
            border-color: #38bdf8;
            transform: scale(1.05);
        }

        /* VFX */
        .particle {
            position: absolute;
            pointer-events: none;
            animation: rise 1.5s ease-out forwards;
            z-index: 100;
        }
        @keyframes rise {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.2); opacity: 0; }
        }

        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Explosion Animation */
        .explode-anim { animation: explode 0.8s ease-in-out forwards; }
        @keyframes explode {
            0% { transform: scale(1); filter: brightness(1); }
            40% { transform: scale(0.8); filter: brightness(0.5) hue-rotate(90deg); }
            100% { transform: scale(3); opacity: 0; filter: brightness(10) blur(10px); }
        }

        /* Screen Flashes */
        .flash-red { animation: flashRed 0.5s ease-out forwards; }
        @keyframes flashRed {
            0% { box-shadow: inset 0 0 0 0 rgba(244, 63, 94, 0); }
            10% { box-shadow: inset 0 0 100px 50px rgba(244, 63, 94, 0.5); }
            100% { box-shadow: inset 0 0 0 0 rgba(244, 63, 94, 0); }
        }

        .flash-green { animation: flashGreen 0.5s ease-out forwards; }
        @keyframes flashGreen {
            0% { box-shadow: inset 0 0 0 0 rgba(52, 211, 153, 0); }
            10% { box-shadow: inset 0 0 100px 50px rgba(52, 211, 153, 0.5); }
            100% { box-shadow: inset 0 0 0 0 rgba(52, 211, 153, 0); }
        }

        /* CRT Scanline Effect */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100; /* above everything as all panels are z-50 */
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Tutorial Overlay Animation */
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Floating Anim for Shop */
        @keyframes floatUpFade {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.1); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="app-scaler" class="crt">
        <!-- Overlay container for flashes -->
        <div id="flash-overlay" class="absolute inset-0 pointer-events-none z-[60]"></div>

        <div class="flex flex-col h-full w-full" id="game-wrapper">
            <!-- TOP HUD -->
            <div class="h-24 flex justify-between items-center bg-slate-900/90 px-8 border-b border-slate-700 relative z-20 shadow-lg">
                <div class="flex flex-col">
                    <h1 class="text-3xl font-bold text-sky-400 tracking-tighter drop-shadow-lg leading-none">INTEGREAT!</h1>
                    <div class="text-xs text-slate-500 font-bold uppercase tracking-widest mt-1">The Calculus Roguelike</div>
                </div>
                
                <div class="flex gap-8 text-sm items-center">
                    <!-- Round Info -->
                    <div class="flex flex-col items-center min-w-[80px]">
                        <div class="text-[10px] text-slate-400 uppercase tracking-widest font-bold">Round</div>
                        <div class="flex gap-1 text-2xl font-bold text-white">
                            <span id="round-display">1</span> 
                            <span>
                                <div class="text-[8px] text-slate-500 uppercase tracking-widest font-bold" style="text-align: center; line-height: normal; transform: translateY(2px);">Level</div>
                                <div class="text-sm text-slate-500" style="text-align: center;" id="level-display">1/5</div>
                            </span>
                        </div>
                    </div>

                    <!-- Score -->
                    <div class="flex flex-col items-center min-w-[100px] bg-slate-800/50 p-2 rounded border border-slate-700 relative">
                        <div class="text-[10px] text-emerald-400 uppercase tracking-widest font-bold">Round Score</div>
                        <div id="score-display" class="text-2xl font-bold text-emerald-300">0</div>
                        <!-- Score VFX Anchor -->
                        <div id="score-vfx-anchor" class="absolute top-0 right-0 w-0 h-0"></div>
                    </div>

                    <!-- Multiplier -->
                    <div class="flex flex-col items-center min-w-[80px]">
                        <div class="text-[10px] text-amber-400 uppercase tracking-widest font-bold">Mult</div>
                        <div class="text-2xl font-bold text-amber-300">x<span id="mult-display">1.0</span></div>
                    </div>

                    <!-- Coins -->
                    <div class="flex flex-col items-center min-w-[80px]">
                        <div class="text-[10px] text-yellow-500 uppercase tracking-widest font-bold">Coins</div>
                        <div class="text-2xl font-bold text-yellow-400 flex items-center gap-1">
                            <i data-lucide="coins" class="w-4 h-4"></i>
                            <span id="coins-display">0</span>
                        </div>
                    </div>

                    <button onclick="game.toggleSettings()" class="p-2 hover:bg-slate-700 rounded-full transition-colors">
                        <i data-lucide="settings" class="w-6 h-6 text-slate-400"></i>
                    </button>
                </div>
            </div>

            <!-- MAIN GAME AREA -->
            <div class="flex-1 flex p-6 gap-6 min-h-0 relative z-10">
                
                <!-- LEFT: VISUALIZER -->
                <div class="flex-1 bg-slate-900 rounded-2xl border border-slate-700 flex flex-col overflow-hidden relative shadow-2xl">
                    <!-- Enemy Header -->
                    <div class="h-20 px-6 bg-slate-800 border-b border-slate-700 flex justify-between items-center shrink-0 relative overflow-hidden">
                        
                        <!-- Explosive Warning Background -->
                        <div id="boss-warning-bg" class="absolute inset-0 bg-rose-900/20 hidden animate-pulse"></div>

                        <div class="flex flex-col justify-center relative z-10">
                            <div class="flex items-center gap-2">
                                <div class="text-xs text-rose-400 font-bold uppercase tracking-widest">Enemy Function</div>
                                <span id="explosive-badge" class="hidden px-2 py-0.5 bg-rose-600 text-white text-[10px] font-bold rounded uppercase tracking-wider animate-pulse">Explosive</span>
                            </div>
                            <div id="function-display" class="text-3xl font-bold text-white font-serif italic tracking-wide mt-1">f(x) = ?</div>
                        </div>
                        
                        <div class="text-right w-1/3 relative z-10">
                            <div class="flex justify-between text-xs mb-1 font-bold">
                                <span class="text-slate-400">ENEMY HP</span>
                                <span id="hp-text" class="text-slate-200">100/100</span>
                            </div>
                            <div class="h-4 bg-slate-950 rounded-full overflow-hidden border border-slate-600 relative">
                                <div id="hp-bar" class="h-full bg-rose-500 transition-all duration-300" style="width: 100%"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Canvas -->
                    <div class="flex-1 relative bg-[#050505] cursor-move overflow-hidden group">
                        <canvas id="graph-canvas" class="block w-full h-full"></canvas>
                        
                        <!-- Antiderivative Hint -->
                        <div id="math-feedback" class="absolute top-4 right-4 text-right pointer-events-none transition-opacity duration-300 opacity-0">
                            <div class="bg-slate-900/90 backdrop-blur p-4 rounded-xl border border-slate-700 shadow-xl">
                                <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold mb-1">Antiderivative F(x)</div>
                                <div id="antideriv-display" class="text-2xl text-sky-400 font-serif italic">?</div>
                            </div>
                        </div>

                        <div class="absolute bottom-4 left-4 pointer-events-none text-xs text-slate-600 opacity-50 group-hover:opacity-100 transition-opacity">
                            Scroll to Zoom • Drag to Pan
                        </div>
                    </div>
                </div>

                <!-- RIGHT: INTEGRATION CONSOLE -->
                <div class="w-[400px] flex flex-col gap-4">
                    
                    <!-- Main Console -->
                    <div class="bg-slate-800 rounded-2xl border border-slate-700 shadow-xl overflow-hidden flex flex-col relative">
                        <!-- Scanline overlay specific to console -->
                        <div class="absolute inset-0 bg-gradient-to-b from-transparent to-slate-900/50 pointer-events-none"></div>

                        <div class="p-3 bg-slate-700/50 border-b border-slate-700 text-center">
                            <h2 class="text-xs font-bold text-slate-300 uppercase tracking-[0.3em]">Integration Console</h2>
                        </div>
                        
                        <div class="p-6 flex flex-col items-center gap-4 bg-slate-800 relative z-10">
                            
                            <!-- Integral UI -->
                            <div class="flex items-center justify-center gap-6 w-full py-2">
                                <div class="text-slate-500 font-serif italic text-[6rem] leading-none select-none relative" style="top: -10px;">∫</div>
                                
                                <!-- Slots Container -->
                                <div class="flex flex-col justify-between h-28">
                                    <!-- Upper Bound (b) -->
                                    <div id="slot-b" class="slot w-16 h-12 bg-slate-900 border-2 border-dashed border-slate-600 rounded-lg flex items-center justify-center text-xl font-bold text-white cursor-pointer hover:border-sky-400 transition-colors shadow-inner" data-slot="b">
                                        <span class="text-slate-600 text-xs pointer-events-none font-sans">b</span>
                                    </div>
                                    
                                    <!-- Lower Bound (a) -->
                                    <div id="slot-a" class="slot w-16 h-12 bg-slate-900 border-2 border-dashed border-slate-600 rounded-lg flex items-center justify-center text-xl font-bold text-white cursor-pointer hover:border-sky-400 transition-colors shadow-inner" data-slot="a">
                                        <span class="text-slate-600 text-xs pointer-events-none font-sans">a</span>
                                    </div>
                                </div>

                                <div class="text-2xl font-serif italic text-white/50">f(x) dx</div>
                            </div>

                            <!-- Preview Screen -->
                            <div class="w-full space-y-1">
                                <div class="flex justify-between items-end px-1">
                                    <div class="text-[10px] text-slate-400 uppercase tracking-wider font-bold">Evaluation (FToC)</div>
                                    <div class="text-[10px] text-emerald-400 font-bold tracking-wider opacity-0" id="hint-indicator">HINTS ACTIVE</div>
                                </div>
                                <div class="bg-slate-950 p-3 rounded-lg border border-slate-700 font-mono text-sm text-center shadow-[inset_0_2px_4px_rgba(0,0,0,0.5)]">
                                    <div id="calculation-preview" class="text-lg text-white/90">
                                        ? - ? = <span class="text-slate-600">?</span>
                                    </div>
                                </div>
                                <div id="validation-msg" class="text-[12px] text-rose-500 text-center h-4 font-bold tracking-wide"></div>
                            </div>

                            <!-- Action Button -->
                            <button id="btn-integrate" class="w-full py-3 bg-sky-600 hover:bg-sky-500 text-white font-bold text-xl tracking-widest rounded-lg shadow-[0_4px_0_rgb(12,74,110)] active:shadow-none active:translate-y-1 transition-all disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none disabled:active:translate-y-0" disabled>
                                INTEGRATE
                            </button>
                        </div>
                    </div>

                    <!-- Message Log -->
                    <div class="bg-slate-900 rounded-xl border-l-4 border-slate-600 p-4 min-h-[4.5rem] flex items-center justify-center text-center shadow-lg">
                        <div id="message-log" class="text-sm text-slate-400 font-medium">
                            Drag cards to start integrating.
                        </div>
                    </div>

                </div>
            </div>

            <!-- BOTTOM: HAND & POWERUPS -->
            <div class="h-44 bg-slate-900 border-t border-slate-700 relative z-20 flex shadow-[0_-10px_40px_rgba(0,0,0,0.5)] overflow-visible">
                
                <!-- Hand Side -->
                <div class="flex-1 flex flex-col min-w-0 border-r border-slate-700">
                    <div class="relative z-10 text-[10px] text-slate-500 px-6 py-2 uppercase tracking-widest font-bold flex justify-between" style="z-index: 1;">
                        <span>Your Deck</span>
                        <span class="text-sky-500" id="tutorial-msg"></span>
                    </div>
                    <!-- Cards -->
                    <div class="relative z-20 flex-1 overflow-x-auto px-6 pt-3 pb-0 flex items-center gap-4" id="hand-container">
                        <!-- Cards Injected Here -->
                    </div>
                </div>

                <!-- Powerups Side -->
                <div class="w-32 bg-slate-800 flex flex-col p-2 gap-2" id="powerups-container">
                    <!-- Buttons Injected Here -->
                    <div class="text-[10px] text-slate-500 uppercase text-center font-bold tracking-widest mb-1">Items</div>
                </div>

            </div>

        </div>
    

        <!-- SCREENS & MODALS -->

        <!-- Tutorial Popup Modal -->
        <div id="tutorial-modal" class="hidden absolute bottom-48 left-1/2 transform -translate-x-1/2 z-50 w-[500px]">
            <div class="bg-slate-800/95 border border-sky-500/50 p-6 rounded-xl shadow-2xl backdrop-blur-md relative animate-[slideIn_0.3s_ease-out]">
                <h3 class="text-sky-400 font-bold uppercase tracking-wider mb-2" id="tutorial-title">Tutorial</h3>
                <p class="text-slate-200 text-sm leading-relaxed mb-4" id="tutorial-body">...</p>
                <div class="text-right">
                    <button onclick="document.getElementById('tutorial-modal').classList.add('hidden')" class="text-xs text-slate-500 hover:text-white uppercase font-bold tracking-widest">Dismiss</button>
                </div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 bg-slate-950 z-50 flex items-center justify-center">
            <div class="max-w-4xl w-full p-10 bg-slate-900 border border-slate-700 rounded-3xl shadow-2xl flex flex-col items-center relative overflow-hidden">
                <!-- Decorative BG -->
                <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0wIDQwaDQwVjBIMHY0MHptMjAgMjBWMjBoMjB2MjBIMjB6IiBmaWxsPSIjMWUyOTNiIiBmaWxsLW9wYWNpdHk9IjAuMSIvPjwvZz48L3N2Zz4=')] opacity-20"></div>
                
                <h1 class="text-7xl font-bold text-sky-400 tracking-tighter mb-4 drop-shadow-2xl relative z-10">INTEGREAT!</h1>
                <p class="text-slate-400 text-xl mb-10 font-light relative z-10">The Calculus Roguelike</p>
                
                <div class="grid grid-cols-2 gap-8 text-left mb-10 w-full relative z-10">
                    <div class="bg-slate-800/80 p-6 rounded-2xl border border-slate-700 backdrop-blur-sm">
                        <h3 class="text-sky-400 font-bold mb-3 flex items-center gap-2 text-lg"><i data-lucide="calculator" class="w-5 h-5"></i> Core Mechanics</h3>
                        <ul class="text-sm text-slate-300 space-y-2 list-disc pl-5 leading-relaxed">
                            <li>Calculate area: $\int_a^b f(x) dx$.</li>
                            <li><b>Damage = Area</b>.</li>
                            <li><b>Overkill Penalty:</b> Dealing extra damage reduces score! Formula: $1 + 2 \times \%_{extra}$.</li>
                            <li><b>Exact Kill:</b> Hit 0 HP exactly for a massive bonus!</li>
                        </ul>
                    </div>
                    <div class="bg-slate-800/80 p-6 rounded-2xl border border-slate-700 backdrop-blur-sm">
                        <h3 class="text-rose-400 font-bold mb-3 flex items-center gap-2 text-lg"><i data-lucide="bomb" class="w-5 h-5"></i> Danger Zones</h3>
                        <ul class="text-sm text-slate-300 space-y-2 list-disc pl-5 leading-relaxed">
                            <li><b>Explosive Bosses:</b> Appear every 3 rounds.</li>
                            <li><b>The Rule:</b> You MUST kill them exactly.</li>
                            <li><b>Failure:</b> Overkilling a Boss ends the run instantly.</li>
                            <li>Regular Explosives reset Round Score to 0.</li>
                        </ul>
                    </div>
                </div>

                <div class="flex gap-6 relative z-10">
                    <button onclick="game.startTutorial()" class="px-8 py-4 bg-slate-700 hover:bg-slate-600 text-white font-bold text-lg rounded-xl transition-all border border-slate-600 hover:border-slate-500">
                        PLAY TUTORIAL
                    </button>
                    <button onclick="game.startRun()" class="px-12 py-4 bg-sky-600 hover:bg-sky-500 text-white font-bold text-lg rounded-xl shadow-lg shadow-sky-900/50 transition-all hover:-translate-y-1">
                        START NEW RUN
                    </button>
                </div>
                
                <div class="mt-8 text-xs text-slate-600 font-mono relative z-10">
                    Made by Rohan Inampudi
                </div>
            </div>
        </div>

        <!-- SHOP / ROUND END SCREEN -->
        <div id="shop-screen" class="hidden absolute inset-0 bg-slate-950 z-40 flex items-center justify-center">
            <div class="max-w-3xl w-full p-8 bg-slate-900 border border-slate-700 rounded-3xl shadow-2xl text-center relative overflow-hidden">
                <!-- Decorative BG -->
                <div class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0wIDQwaDQwVjBIMHY0MHptMjAgMjBWMjBoMjB2MjBIMjB6IiBmaWxsPSIjMWUyOTNiIiBmaWxsLW9wYWNpdHk9IjAuMSIvPjwvZz48L3N2Zz4=')] opacity-20"></div>

                <h2 class="text-4xl font-bold text-white mb-2 relative z-10">ROUND COMPLETE</h2>
                <div class="w-24 h-1 bg-sky-500 mx-auto mb-8 rounded-full relative z-10"></div>

                <!-- Score Animation Area -->
                <div class="relative z-10 mb-8 font-mono text-xl grid grid-cols-3 gap-4" id="shop-anim-area">
                    <!-- Dynamic Animation will happen here -->
                    <div class="flex flex-col items-center bg-slate-800 p-4 rounded-xl border border-slate-700">
                        <div class="text-xs text-slate-400 mb-1">ROUND SCORE</div>
                        <div class="text-3xl text-white font-bold" id="shop-score">0</div>
                    </div>
                    <div class="flex flex-col items-center bg-slate-800 p-4 rounded-xl border border-slate-700">
                        <div class="text-xs text-amber-400 mb-1">MULT</div>
                        <div class="text-3xl text-amber-300 font-bold" id="shop-mult">x1.0</div>
                    </div>
                    <div class="flex flex-col items-center bg-slate-800 p-4 rounded-xl border border-slate-700 relative">
                        <div class="text-xs text-yellow-500 mb-1">TOTAL COINS</div>
                        <div class="text-3xl text-yellow-400 font-bold" id="shop-coins">0</div>
                        <div id="coin-plus-vfx" class="absolute top-1/2 left-full ml-2 text-2xl font-bold text-emerald-400 opacity-0 transform -translate-y-1/2">+0</div>
                    </div>
                </div>

                <!-- Shop Items -->
                <div class="bg-slate-800/80 p-6 rounded-xl border border-dashed border-slate-700 mb-8 relative z-10">
                    <div class="flex items-center justify-center gap-2 mb-4">
                        <i data-lucide="shopping-cart" class="w-5 h-5 text-slate-400"></i>
                        <h3 class="text-lg font-bold text-slate-300 uppercase tracking-widest">Supply Shop</h3>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <!-- Trash Can -->
                        <div class="bg-slate-900 p-4 rounded border border-slate-700 flex justify-between items-center group hover:border-sky-500 transition-colors">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-slate-800 rounded flex items-center justify-center text-slate-400 group-hover:text-white group-hover:bg-rose-500/20 transition-colors">
                                    <i data-lucide="trash-2" class="w-6 h-6"></i>
                                </div>
                                <div class="text-left">
                                    <div class="text-white font-bold">Trash Can</div>
                                    <div class="text-[10px] text-slate-400 w-32">Remove 1 Junk card from hand.</div>
                                </div>
                            </div>
                            <button onclick="game.buyItem('trash', 2)" class="px-3 py-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold text-sm rounded flex items-center gap-1 transition-colors">
                                <i data-lucide="coins" class="w-3 h-3"></i> 2
                            </button>
                        </div>

                        <!-- Quick Hint -->
                        <div class="bg-slate-900 p-4 rounded border border-slate-700 flex justify-between items-center group hover:border-sky-500 transition-colors">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-slate-800 rounded flex items-center justify-center text-slate-400 group-hover:text-white group-hover:bg-emerald-500/20 transition-colors">
                                    <i data-lucide="lightbulb" class="w-6 h-6"></i>
                                </div>
                                <div class="text-left">
                                    <div class="text-white font-bold">Quick Hint</div>
                                    <div class="text-[10px] text-slate-400 w-32">Highlights a perfect pair.</div>
                                </div>
                            </div>
                            <button onclick="game.buyItem('hint', 3)" class="px-3 py-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold text-sm rounded flex items-center gap-1 transition-colors">
                                <i data-lucide="coins" class="w-3 h-3"></i> 3
                            </button>
                        </div>
                    </div>
                </div>
                
                <div id="next-round-warning" class="mb-4 text-rose-400 font-bold uppercase tracking-widest animate-pulse hidden relative z-10">
                    Warning: Explosive Boss Approaching
                </div>

                <button onclick="game.nextRound()" class="px-10 py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold text-xl rounded-xl shadow-lg transition-all transform hover:-translate-y-1 relative z-10">
                    START NEXT ROUND
                </button>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="hidden absolute inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm">
            <div class="w-96 bg-slate-900 border border-slate-700 rounded-xl shadow-2xl overflow-hidden">
                <div class="p-4 bg-slate-800 border-b border-slate-700 flex justify-between items-center">
                    <h2 class="text-white font-bold">Settings</h2>
                    <button onclick="game.toggleSettings()" class="text-slate-400 hover:text-white"><i data-lucide="x" class="w-5 h-5"></i></button>
                </div>
                <div class="p-6 space-y-6">
                    <!-- Hints Toggle -->
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-white font-bold">Enable Hints</div>
                            <div class="text-xs text-slate-400 w-48">Show antiderivative and calculation preview.</div>
                        </div>
                        <button id="btn-hints" onclick="game.toggleHints()" class="w-12 h-6 rounded-full bg-slate-700 relative transition-colors">
                            <div id="hint-knob" class="w-4 h-4 bg-white rounded-full absolute top-1 left-1 transition-transform"></div>
                        </button>
                    </div>
                    <div class="pt-4 border-t border-slate-800">
                        <button onclick="location.reload()" class="w-full py-2 bg-rose-900/50 hover:bg-rose-900 text-rose-200 text-sm font-bold rounded border border-rose-800 transition-colors">ABORT RUN</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden absolute inset-0 bg-slate-950/90 z-50 flex items-center justify-center flex-col gap-6 backdrop-blur">
            <h1 class="text-7xl font-bold text-rose-500 mb-2 drop-shadow-[0_0_25px_rgba(244,63,94,0.6)] animate-pulse">GAME OVER</h1>
            
            <div class="bg-slate-900 p-8 rounded-2xl border border-slate-800 min-w-[350px] text-center shadow-2xl">
                <div id="death-reason" class="text-xl text-white font-bold mb-6 border-b border-slate-800 pb-4">Use Reason Here</div>
                
                <div class="grid grid-cols-2 gap-4 mb-2">
                    <div>
                        <div class="text-xs text-slate-500 uppercase tracking-widest">Rounds</div>
                        <div id="final-round" class="text-2xl font-bold text-white">0</div>
                    </div>
                    <div>
                        <div class="text-xs text-slate-500 uppercase tracking-widest">Coins</div>
                        <div id="final-coins" class="text-2xl font-bold text-yellow-400">0</div>
                    </div>
                </div>
            </div>
            <button onclick="location.reload()" class="px-10 py-4 bg-white text-slate-900 font-bold rounded-xl hover:bg-sky-400 hover:text-white transition-colors text-lg">TRY AGAIN</button>
        </div>
    </div>

    <script>
        // Init Icons
        lucide.createIcons();

        // --- HELPER ANIMATIONS ---
        function spawnFloatingText(text, x, y, colorClass, delay = 0) {
            setTimeout(() => {
                const el = document.createElement('div');
                el.className = `particle text-4xl font-bold fixed z-50 drop-shadow-lg ${colorClass}`;
                el.style.left = `${x}px`;
                el.style.top = `${y}px`;
                el.innerHTML = text;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 1500);
            }, delay);
        }

        // Returns Promise that resolves when animation done
        function animateValue(obj, start, end, duration) {
            return new Promise(resolve => {
                let startTimestamp = null;
                const step = (timestamp) => {
                    if (!startTimestamp) startTimestamp = timestamp;
                    const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                    obj.innerHTML = Math.floor(progress * (end - start) + start);
                    if (progress < 1) {
                        window.requestAnimationFrame(step);
                    } else {
                        resolve();
                    }
                };
                window.requestAnimationFrame(step);
            });
        }
        
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // --- MATH ENGINE ---
        
        // Helper to convert float to fraction string (e.g. 0.333 -> 1/3)
        function floatToFraction(x) {
            const tolerance = 1.0E-6;
            let h1 = 1, h2 = 0, k1 = 0, k2 = 1;
            let b = x;
            do {
                let a = Math.floor(b);
                let aux = h1; h1 = a * h1 + h2; h2 = aux;
                aux = k1; k1 = a * k1 + k2; k2 = aux;
                b = 1 / (b - a);
            } while (Math.abs(x - h1 / k1) > x * tolerance);
            
            if (k1 === 1) return `${h1}`; // Integer
            return `(${h1}/${k1})`; // Surround with parentheses
        }

        // Mixed Number Formatter
        function toMixed(num) {
            if (Math.abs(num) < 0.001) return "0";
            let sign = num < 0 ? "-" : "";
            num = Math.abs(num);
            let intPart = Math.floor(num);
            let decPart = num - intPart;
            
            if (decPart < 0.001) return `${sign}${intPart}`;
            
            // Float to frac logic for decPart
            let frac = floatToFraction(decPart); // returns "(n/d)"
            // Remove parens for mixed number display aesthetic: 1 (1/3) vs 1 1/3
            // Keeping parens for clarity per user request style preference or standard mixed
            // User asked for: "1 (1/3)"
            if (frac.startsWith('(')) {
                if (intPart === 0) return `${sign}${frac}`;
                return `${sign}${intPart} ${frac}`;
            }
            return `${sign}${num.toFixed(2)}`; // Fallback
        }

        class Term {
            constructor(coeff, power) { this.coeff = coeff; this.power = power; }
            integrate() { return new Term(this.coeff / (this.power + 1), this.power + 1); }
            evaluate(x) { return this.coeff * Math.pow(x, this.power); }
            toHTML() {
                if (this.coeff === 0) return null;
                if (this.power === 0) return floatToFraction(this.coeff); // Use fraction display
                
                let cStr = this.coeff === 1 ? "" : (this.coeff === -1 ? "-" : floatToFraction(this.coeff));
                if (this.power === 1) return `${cStr}x`;
                return `${cStr}x<sup>${this.power}</sup>`;
            }
        }

        class Polynomial {
            constructor(terms) { this.terms = terms; }
            integrate() { return new Polynomial(this.terms.map(t => t.integrate())); }
            evaluate(x) { return this.terms.reduce((sum, t) => sum + t.evaluate(x), 0); }
            toDisplay() {
                if (this.terms.length === 0) return "0";
                return this.terms.map(t => t.toHTML()).filter(term => term !== null).join(" + ").replace(/\+ -/g, "- ");
            }
        }

        // --- LEVEL GENERATION ---
        class LevelGenerator {
            static generate(round, isBoss, bossTypes = []) {
                let diffMin = round - 1;
                let diffMax = round + 1;
                if (round === 1) { diffMin = 1; diffMax = 2; }
                
                let difficulty = isBoss ? round : Math.floor(Math.random() * (diffMax - diffMin + 1)) + diffMin;
                difficulty = Math.max(1, difficulty); 

                let terms = [];
                
                // Poly Gen
                if (difficulty <= 2) {
                    terms.push(new Term(1 + Math.floor(Math.random()*3), 1));
                    if(Math.random() > 0.5) terms.push(new Term(1 + Math.floor(Math.random()*5), 0));
                } else if (difficulty <= 5) {
                    terms.push(new Term(1 + Math.floor(Math.random()*2), 2));
                    terms.push(new Term(Math.floor(Math.random()*4), 0));
                } else {
                    terms.push(new Term(1 + Math.floor(Math.random()*2), 3));
                    terms.push(new Term(Math.floor(Math.random()*3), 1));
                }

                terms = terms.filter(t => t.coeff !== 0);
                if (terms.length === 0) terms.push(new Term(1, 0));

                const func = new Polynomial(terms);
                const anti = func.integrate();

                const isExplosive = (isBoss && bossTypes.includes('explosive')) || (!isBoss && Math.random() < 0.15 && round > 1);
                
                let targetHP = 0;
                let requiredCards = [];
                
                const numPairs = 2 + Math.floor(difficulty / 3);

                for(let i=0; i<numPairs; i++) {
                    const a = Math.floor(Math.random() * 5); 
                    const b = a + 1 + Math.floor(Math.random() * 3); 
                    const dmg = anti.evaluate(b) - anti.evaluate(a);
                    
                    if(dmg > 0.1) {
                        targetHP += dmg;
                        requiredCards.push({ value: a, isJunk: false });
                        requiredCards.push({ value: b, isJunk: false });
                    }
                }

                // Junk
                const junkCount = Math.max(0, Math.floor(Math.random() * 3) + (difficulty > 3 ? 2 : 0));
                for(let i=0; i<junkCount; i++) {
                    requiredCards.push({ value: Math.floor(Math.random() * 8), isJunk: true });
                }
                
                requiredCards.sort(() => Math.random() - 0.5);

                return {
                    terms: terms,
                    hp: targetHP, 
                    hand: requiredCards,
                    isExplosive: isExplosive,
                    isBoss: isBoss,
                    bossTypes: isBoss ? bossTypes : [],
                    difficulty: difficulty
                };
            }
        }

        // --- GAME LOGIC ---

        class Game {
            constructor() {
                // State
                this.mode = 'menu'; 
                this.round = 1;
                this.levelInRound = 1;
                this.levelsPerRound = 5;
                
                this.totalScore = 0; 
                this.roundScore = 0; 
                this.displayRoundScore = 0; 
                this.coins = 0;
                this.mult = 1.0;
                
                this.hand = [];
                this.currentFunction = null; 
                this.currentAntideriv = null; 
                this.enemyHP = 0;
                this.maxHP = 0;
                this.difficulty = 1;
                this.isExplosive = false;
                this.isBoss = false;
                this.currentBossTypes = [];

                // Inventory
                this.inventory = {
                    trash: 0,
                    hint: 0
                };
                this.hintUsedThisLevel = false;

                // Tutorial State
                this.tutorialStep = 0;

                // UI
                this.slotA = null;
                this.slotB = null;
                this.hintsEnabled = false;

                // Rendering
                this.canvas = document.getElementById('graph-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.pan = { x: 0, y: 0, zoom: 1 };
                this.isDraggingGraph = false;
                this.lastMousePos = { x: 0, y: 0 };
                
                // Init
                this.resizeGame();
                window.addEventListener('resize', () => this.resizeGame());
                this.bindInputs();
            }

            resizeGame() {
                const scaler = document.getElementById('app-scaler');
                const scale = Math.min(window.innerWidth / 1280, window.innerHeight / 800);
                scaler.style.transform = `scale(${scale})`;
                if(this.currentFunction) this.renderGraph();
            }

            bindInputs() {
                document.getElementById('btn-integrate').addEventListener('click', () => this.performIntegration());
                this.setupDragDrop();
                
                // Graph Inputs
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.pan.zoom *= Math.exp(-e.deltaY * 0.001);
                    this.pan.zoom = Math.max(0.1, Math.min(this.pan.zoom, 5));
                    this.renderGraph();
                });
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDraggingGraph = true;
                    this.lastMousePos = { x: e.clientX, y: e.clientY };
                });
                window.addEventListener('mousemove', (e) => {
                    if (!this.isDraggingGraph) return;
                    const scale = parseFloat(document.getElementById('app-scaler').style.transform.replace('scale(', '')) || 1;
                    this.pan.x += (e.clientX - this.lastMousePos.x) / scale;
                    this.pan.y += (e.clientY - this.lastMousePos.y) / scale;
                    this.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.renderGraph();
                });
                window.addEventListener('mouseup', () => this.isDraggingGraph = false);
            }

            // --- FLOW ---

            startTutorial() {
                this.mode = 'tutorial';
                this.round = 1;
                this.levelInRound = 1;
                this.levelsPerRound = 2;
                this.coins = 0;
                this.roundScore = 0;
                this.displayRoundScore = 0;
                this.totalScore = 0;
                this.tutorialStep = 1;
                this.inventory = { trash: 0, hint: 0 };
                document.getElementById('start-screen').classList.add('hidden');
                
                // Tutorial Step 1
                this.loadData({
                    terms: [new Term(2, 0)], 
                    hp: 10,
                    hand: [0, 5, 2, 3, 4], // Treated as raw numbers in loadData but we need to ensure junk logic
                    isExplosive: false,
                    isBoss: false,
                    difficulty: 1
                });
                // Manually set junk status for tutorial hands in loadData override or just assume false for manual arrays
                this.showTutorialPopup("Basics", "Welcome! The goal is to defeat the Enemy Function by calculating area.<br><br><b>Drag '0' to 'a' and '5' to 'b'</b> to calculate $\\int_0^5 2 dx$.<br><br>You can <b>Pan</b> the graph by dragging and <b>Zoom</b> with your scroll wheel.");
                this.showTutorialMsg("Tutorial: Basic Integration");
                this.drawLoop();
            }

            advanceTutorial() { 
                this.tutorialStep++;
                
                if (this.tutorialStep === 2) {
                    this.levelInRound = 2;
                    this.loadData({
                        terms: [new Term(1, 1)], 
                        hp: 12, 
                        hand: [0, 4, 0, 6],
                        isExplosive: false,
                        isBoss: false,
                        difficulty: 1
                    });
                    this.showTutorialPopup("Scoring Rules", "Every card you use increases your <b>Multiplier</b> by +0.1.<br><br><b>Overkill Penalty:</b> If you deal more damage than HP, you lose score! The penalty is <b>Amplified</b> ($1 + 2\\times\\%_{excess}$) based on how much you miss by.<br><br><b>Perfect Kill:</b> Hit 0 HP exactly for a bonus ($1 \\times MaxHP$).");
                }
                else if (this.tutorialStep === 3) {
                    this.endRound(); 
                    this.showTutorialPopup("Round Complete", "At the end of a round, your <b>Round Score</b> is multiplied by your <b>Card Mult</b> and divided by 100 to calculate <b>Coins</b> ($\\frac{Score \\times Mult}{100}$).<br><br>Coins can be spent on upgrades in the Shop!");
                }
                else if (this.tutorialStep === 4) {
                    this.round = 2; 
                    this.levelInRound = 1; 
                    const bossData = LevelGenerator.generate(3, true, ['explosive']); 
                    this.loadData(bossData);
                    document.getElementById('shop-screen').classList.add('hidden');
                    this.showTutorialPopup("BOSS BATTLE", "This is an <b>Explosive Boss</b>.<br><br>You <b>MUST</b> hit 0 HP exactly. If you overkill an Explosive Boss, the run ends immediately.<br><br>Calculate carefully!");
                    this.showTutorialMsg("Tutorial: Explosive Boss");
                }
                else if (this.tutorialStep === 5) {
                    this.showTutorialPopup("Tutorial Complete", "You survived! You are now ready for the real challenge.<br><br>Good luck!");
                    setTimeout(() => {
                        this.showTutorialMsg("");
                        document.getElementById('start-screen').classList.remove('hidden');
                    }, 4000);
                }
            }

            startRun() {
                this.mode = 'run';
                this.round = 1;
                this.coins = 0;
                this.totalScore = 0;
                this.inventory = { trash: 0, hint: 0 };
                this.startRound();
                document.getElementById('start-screen').classList.add('hidden');
                this.drawLoop();
            }

            startRound() {
                this.roundScore = 0; 
                this.displayRoundScore = 0;
                this.mult = 1.0;
                this.levelInRound = 1;
                this.levelsPerRound = 5 + Math.floor(Math.random() * 4); 
                
                this.updateGlobalUI();
                this.nextLevel();
            }

            nextLevel() {
                if (this.levelInRound > this.levelsPerRound) {
                    this.endRound();
                    return;
                }
                const isBossRound = (this.round % 3 === 0);
                if (isBossRound) this.levelsPerRound = 1;
                
                const bossTypes = ['explosive'];
                const data = LevelGenerator.generate(this.round, isBossRound, bossTypes);
                this.loadData(data);
            }

            loadData(data) {
                this.currentFunction = new Polynomial(data.terms);
                this.currentAntideriv = this.currentFunction.integrate();
                this.maxHP = data.hp;
                this.enemyHP = data.hp;
                this.isExplosive = data.isExplosive;
                this.isBoss = data.isBoss;
                this.currentBossTypes = data.bossTypes || [];
                this.difficulty = data.difficulty;
                
                // Map hand. If raw numbers (tutorial), assume non-junk
                this.hand = data.hand.map(item => {
                    const val = typeof item === 'object' ? item.value : item;
                    const junk = typeof item === 'object' ? item.isJunk : false;
                    return { id: Math.random().toString(36), value: val, isJunk: junk };
                });

                this.slotA = null; this.slotB = null;
                this.updateSlotUI();
                this.pan = { x: 0, y: 0, zoom: 1 };
                this.hintUsedThisLevel = false;
                
                document.getElementById('function-display').innerHTML = `f(x) = ${this.currentFunction.toDisplay()}`;
                document.getElementById('antideriv-display').innerHTML = this.currentAntideriv.toDisplay();
                
                const badge = document.getElementById('explosive-badge');
                const warning = document.getElementById('boss-warning-bg');
                if (this.isExplosive) {
                    badge.classList.remove('hidden');
                    warning.classList.remove('hidden');
                    document.getElementById('function-display').classList.add('text-rose-200');
                } else {
                    badge.classList.add('hidden');
                    warning.classList.add('hidden');
                    document.getElementById('function-display').classList.remove('text-rose-200');
                }

                this.updateGlobalUI();
                this.updateHPUI();
                this.renderHand();
                this.renderPowerups();
                this.renderGraph();
            }

            // --- SHOP & ANIMATION ---

            async animateRoundEndSequence() {
                const scoreEl = document.getElementById('shop-score');
                const multEl = document.getElementById('shop-mult');
                const coinsEl = document.getElementById('shop-coins');
                const animArea = document.getElementById('shop-anim-area');
                const plusVfx = document.getElementById('coin-plus-vfx');

                // 1. Initial State
                scoreEl.innerHTML = this.roundScore;
                multEl.innerHTML = `x${this.mult.toFixed(1)}`;
                coinsEl.innerHTML = this.coins;
                plusVfx.style.opacity = '0';
                
                // Reset styling on score container from any previous runs
                scoreEl.parentElement.style.transform = 'none';
                scoreEl.parentElement.style.zIndex = 'auto';

                await sleep(500);

                // 2. Mult pops under Score (Conceptual logic: we make the score count up)
                const total = Math.floor(this.roundScore * this.mult);
                
                // Spawn "x3.6" VFX
                const rect = scoreEl.getBoundingClientRect();
                spawnFloatingText(`x${this.mult.toFixed(1)}`, rect.left + rect.width/2, rect.top + 50, 'text-amber-400', 0);
                
                // Score Counts up to Total
                await animateValue(scoreEl, this.roundScore, total, 1500);
                
                await sleep(500);

                // 3. Score Pops Out & Big
                const scoreContainer = scoreEl.parentElement;
                scoreContainer.style.transition = "transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
                scoreContainer.style.transform = "scale(1.2)";
                scoreContainer.style.zIndex = "50";
                scoreContainer.style.boxShadow = "0 20px 25px -5px rgba(0, 0, 0, 0.5)";
                scoreEl.classList.add("text-sky-400");
                
                await sleep(600);

                // 4. Line & 100 appear (Visual division)
                // We'll append temporary elements
                const divider = document.createElement('div');
                divider.className = "w-full h-1 bg-white my-1";
                const div100 = document.createElement('div');
                div100.className = "text-center text-slate-300 font-bold";
                div100.innerText = "100";
                scoreContainer.appendChild(divider);
                scoreContainer.appendChild(div100);

                await sleep(800);

                // 5. Fade out divider, count down score to Result
                divider.style.transition = "opacity 0.5s";
                div100.style.transition = "opacity 0.5s";
                divider.style.opacity = "0";
                div100.style.opacity = "0";
                
                const earned = Math.floor(total / 100);
                await animateValue(scoreEl, total, earned, 1000);
                scoreEl.classList.remove("text-sky-400");
                scoreEl.classList.add("text-yellow-400");

                // Cleanup divider
                divider.remove();
                div100.remove();

                await sleep(400);

                // 6. Move Result to Coins
                scoreContainer.style.transform = "scale(1)";
                scoreContainer.style.boxShadow = "none";
                scoreContainer.style.zIndex = "auto";
                
                // Show "+Earned"
                plusVfx.innerHTML = `+${earned}`;
                plusVfx.style.opacity = "1";
                plusVfx.style.animation = "floatUpFade 1.5s forwards";

                // Count up Coins
                const newCoins = this.coins + earned;
                await animateValue(coinsEl, this.coins, newCoins, 1000);
                
                this.coins = newCoins;
                
                // Reset score display for next logic
                await sleep(1000);
            }

            endRound() {
                if (this.mode === 'tutorial' && this.tutorialStep !== 3) return;

                document.getElementById('shop-screen').classList.remove('hidden');
                
                // Trigger Async Animation
                this.animateRoundEndSequence();

                // Warn about next round
                const nextIsBoss = ((this.round + 1) % 3 === 0);
                const warningEl = document.getElementById('next-round-warning');
                if (nextIsBoss) {
                    warningEl.classList.remove('hidden');
                } else {
                    warningEl.classList.add('hidden');
                }
            }

            nextRound() {
                if (this.mode === 'tutorial') {
                    this.advanceTutorial();
                    return;
                }
                this.round++;
                document.getElementById('shop-screen').classList.add('hidden');
                this.startRound();
            }

            // --- ITEMS / SHOP ---
            buyItem(type, cost) {
                if (this.coins >= cost) {
                    this.coins -= cost;
                    this.inventory[type]++;
                    
                    // Update Shop UI
                    document.getElementById('shop-coins').innerText = this.coins;
                    
                    // Spawn particle
                    const rect = document.getElementById('shop-coins').getBoundingClientRect();
                    spawnFloatingText(`- ${cost}`, rect.left + 50, rect.top, 'text-rose-400');
                } else {
                    // Shake coins
                    const c = document.getElementById('shop-coins');
                    c.classList.add('shake');
                    setTimeout(() => c.classList.remove('shake'), 500);
                }
            }

            useTrash() {
                if (this.inventory.trash <= 0) return;
                
                // Logic
                const junkIdx = this.hand.findIndex(c => c.isJunk);
                if (junkIdx === -1) {
                    spawnFloatingText("NO JUNK CARDS!", window.innerWidth/2, window.innerHeight - 200, 'text-slate-400');
                    return;
                }
                
                // Consume
                this.inventory.trash--;
                const removed = this.hand.splice(junkIdx, 1)[0];
                
                spawnFloatingText("TRASHED!", window.innerWidth/2, window.innerHeight - 200, 'text-slate-500');
                
                this.renderHand();
                this.renderPowerups();
            }

            useHint() {
                if (this.inventory.hint <= 0) return;
                if (this.hintUsedThisLevel) {
                    spawnFloatingText("ALREADY USED!", window.innerWidth/2, window.innerHeight - 200, 'text-slate-400');
                    return;
                }

                // Logic: Find a pair that deals <= remaining HP, prioritize Exact
                // Simple: Loop pairs
                let bestPair = null;
                let foundExact = false;
                
                for(let i=0; i<this.hand.length; i++) {
                    for(let j=0; j<this.hand.length; j++) {
                        if (i === j) continue;
                        const c1 = this.hand[i];
                        const c2 = this.hand[j];
                        
                        let a = c1.value;
                        let b = c2.value;
                        if (a >= b) continue;

                        const dmg = this.currentAntideriv.evaluate(b) - this.currentAntideriv.evaluate(a);
                        
                        if (dmg <= this.enemyHP + 0.1) {
                            if (!bestPair) bestPair = [c1.id, c2.id]; // Keep first safe pair
                            
                            if (Math.abs(dmg - this.enemyHP) < 0.1) {
                                bestPair = [c1.id, c2.id]; // Upgrade to exact
                                foundExact = true;
                                break;
                            }
                        }
                    }
                    if (foundExact) break;
                }

                if (bestPair) {
                    this.inventory.hint--;
                    this.hintUsedThisLevel = true;
                    this.renderPowerups(); // Update count
                    
                    // Highlight cards
                    const cardEls = document.querySelectorAll('.card');
                    cardEls.forEach(el => {
                        if (bestPair.includes(el.dataset.id)) {
                            el.classList.add('highlight-hint');
                        }
                    });
                    
                    spawnFloatingText("PAIR FOUND!", window.innerWidth/2, window.innerHeight - 200, 'text-yellow-300');
                } else {
                    spawnFloatingText("NO SAFE PAIR!", window.innerWidth/2, window.innerHeight - 200, 'text-rose-400');
                }
            }

            renderPowerups() {
                const c = document.getElementById('powerups-container');
                // Keep header
                c.innerHTML = '<div class="text-[10px] text-slate-500 uppercase text-center font-bold tracking-widest mb-1">Items</div>';
                
                // Trash Can
                if (this.inventory.trash > 0) {
                    const btn = document.createElement('button');
                    btn.className = "w-full bg-slate-700 hover:bg-slate-600 border border-slate-600 rounded p-2 flex items-center justify-between group transition-all relative";
                    btn.onclick = () => this.useTrash();
                    btn.title = "Remove 1 Junk Card";
                    btn.innerHTML = `
                        <div class="flex items-center gap-2">
                            <i data-lucide="trash-2" class="w-4 h-4 text-slate-400 group-hover:text-white"></i>
                            <span class="text-xs font-bold text-white">Trash</span>
                        </div>
                        <span class="text-xs font-bold text-sky-400 bg-slate-900 px-1.5 rounded">${this.inventory.trash}</span>
                    `;
                    c.appendChild(btn);
                }

                // Hint
                if (this.inventory.hint > 0) {
                    const btn = document.createElement('button');
                    btn.className = `w-full bg-slate-700 hover:bg-slate-600 border border-slate-600 rounded p-2 flex items-center justify-between group transition-all relative ${this.hintUsedThisLevel ? 'opacity-50 cursor-not-allowed' : ''}`;
                    btn.onclick = () => this.useHint();
                    btn.title = "Highlight Perfect Pair";
                    btn.innerHTML = `
                        <div class="flex items-center gap-2">
                            <i data-lucide="lightbulb" class="w-4 h-4 text-yellow-500 group-hover:text-yellow-300"></i>
                            <span class="text-xs font-bold text-white">Hint</span>
                        </div>
                        <span class="text-xs font-bold text-sky-400 bg-slate-900 px-1.5 rounded">${this.inventory.hint}</span>
                    `;
                    c.appendChild(btn);
                }
                
                lucide.createIcons();
            }

            // --- INTERACTIONS ---

            setupDragDrop() {
                ['slot-a', 'slot-b'].forEach(id => {
                    const slot = document.getElementById(id);
                    slot.addEventListener('dragover', e => { e.preventDefault(); slot.classList.add('drag-over'); });
                    slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
                    slot.addEventListener('drop', e => {
                        e.preventDefault();
                        slot.classList.remove('drag-over');
                        this.fillSlot(slot.dataset.slot, JSON.parse(e.dataTransfer.getData('text/plain')));
                    });
                    slot.addEventListener('click', () => {
                        if (id === 'slot-a' && this.slotA) { this.hand.push(this.slotA); this.slotA = null; }
                        if (id === 'slot-b' && this.slotB) { this.hand.push(this.slotB); this.slotB = null; }
                        this.updateSlotUI();
                        this.renderHand();
                    });
                });
            }

            fillSlot(type, card) {
                if (type === 'a') { if(this.slotA) this.hand.push(this.slotA); this.slotA = card; }
                if (type === 'b') { if(this.slotB) this.hand.push(this.slotB); this.slotB = card; }
                this.hand = this.hand.filter(c => c.id !== card.id);
                this.updateSlotUI();
                this.renderHand();
            }

            updateSlotUI() {
                const map = { a: this.slotA, b: this.slotB };
                ['a', 'b'].forEach(k => {
                    const el = document.getElementById(`slot-${k}`);
                    if (map[k]) {
                        el.innerHTML = `<span class="text-3xl text-sky-400 font-bold pointer-events-none">${map[k].value}</span>`;
                        el.classList.add('bg-sky-900', 'border-sky-400');
                    } else {
                        el.innerHTML = `<span class="text-slate-600 text-xs pointer-events-none font-sans">${k}</span>`;
                        el.classList.remove('bg-sky-900', 'border-sky-400');
                    }
                });
                this.updatePreview();
            }

            updatePreview() {
                const btn = document.getElementById('btn-integrate');
                const preview = document.getElementById('calculation-preview');
                const validMsg = document.getElementById('validation-msg');
                
                validMsg.innerText = '';

                if (this.slotA && this.slotB) {
                    const a = parseInt(this.slotA.value);
                    const b = parseInt(this.slotB.value);
                    
                    if (a >= b) {
                        btn.disabled = true;
                        validMsg.innerText = a === b ? "Zero Width (a = b)" : `Invalid: a (${a}) > b (${b})`;
                        preview.innerHTML = `<span class="text-rose-500 font-bold">INVALID BOUNDS</span>`;
                    } else {
                        btn.disabled = false;
                        const Fa = this.currentAntideriv.evaluate(a);
                        const Fb = this.currentAntideriv.evaluate(b);
                        const res = Fb - Fa;
                        
                        if (this.hintsEnabled) {
                            // Use Mixed Numbers for display
                            preview.innerHTML = `<span class="text-sky-400">${toMixed(Fb)}</span> - <span class="text-purple-400">${toMixed(Fa)}</span> = <span class="text-white font-bold">${toMixed(res)}</span>`;
                        } else {
                            preview.innerHTML = `F(${b}) - F(${a}) = <span class="text-white font-bold">?</span>`;
                        }
                    }
                } else {
                    btn.disabled = true;
                    preview.innerHTML = `? - ? = <span class="text-slate-600">?</span>`;
                }
            }

            performIntegration() {
                if (!this.slotA || !this.slotB) return;
                
                // Logic
                const a = parseInt(this.slotA.value);
                const b = parseInt(this.slotB.value);
                const damage = this.currentAntideriv.evaluate(b) - this.currentAntideriv.evaluate(a);
                const intDamage = Math.floor(damage); // Damage is usually integer due to coef choices, but safe floor

                // Consume Cards (don't return to hand)
                this.slotA = null; this.slotB = null;
                this.updateSlotUI();
                
                // Increase Mult
                this.mult += 0.1; // +0.1 per card used (Tutorial req)

                // Check Overkill
                const remaining = this.enemyHP;
                const overkill = damage - remaining;
                
                let scoreChange = 0;
                let logMsg = "";
                let isPerfectKill = false;
                let isOverkill = false;

                // 1. Damage VFX (Orange) - Immediate
                const w = window.innerWidth; const h = window.innerHeight;
                spawnFloatingText(`-${toMixed(damage)}`, w/2, h/2 - 50, 'text-orange-400');
                this.shakeScreen(15, 200);

                if (overkill > 0.01) {
                    // Overkill Logic
                    isOverkill = true;
                    
                    if (this.isExplosive) {
                        // Handled in Explosion Sequence below
                        scoreChange = 0; // Will be reset logic
                    } else {
                        // Normal Overkill Penalty
                        // Formula: (overkill / maxHP) * (difficulty/2)
                        const pct = overkill / this.maxHP; 
                        const difficultyFactor = Math.max(1, this.difficulty / 2);
                        const penaltyMult = 1 + (pct * difficultyFactor); 
                        const deduction = Math.ceil(overkill * penaltyMult); 
                        scoreChange = -deduction;
                        logMsg = `<span class="text-amber-500 font-bold">OVERKILL!</span>`;
                        
                        // Screen Flash Red
                        const overlay = document.getElementById('flash-overlay');
                        overlay.classList.add('flash-red');
                        setTimeout(() => overlay.classList.remove('flash-red'), 500);
                        
                        spawnFloatingText("OVERKILL!", w/2, h/2 - 100, 'text-rose-500 font-black', 100);
                    }
                } else if (Math.abs(overkill) < 0.01) {
                    // Perfect Kill
                    isPerfectKill = true;
                    const bonus = Math.floor(this.maxHP * 1 * Math.max(1, this.difficulty)); // Bonus = MaxHP * Difficulty
                    scoreChange = intDamage + bonus;
                    logMsg = `<span class="text-emerald-400 font-bold">PERFECT KILL!</span>`;

                    // Screen Flash Green
                    const overlay = document.getElementById('flash-overlay');
                    overlay.classList.add('flash-green');
                    setTimeout(() => overlay.classList.remove('flash-green'), 500);

                    spawnFloatingText("PERFECT KILL!", w/2, h/2 - 100, 'text-emerald-400 font-black', 100);
                    
                    // Bonus Text
                    spawnFloatingText(`+${bonus} Bonus`, w/2 + 100, h/2, 'text-emerald-200', 400);
                } else {
                    // Normal Hit
                    scoreChange = intDamage;
                    logMsg = `<span class="text-sky-400 font-bold">HIT!</span> ${toMixed(damage)} Damage`;
                }

                // Update Logic with Animations
                if (!this.isExplosive || !isOverkill) {
                    // Apply Score Logic
                    this.roundScore += Math.floor(scoreChange);
                    if (this.roundScore < 0) this.roundScore = 0;
                    if (scoreChange > 0) this.totalScore += Math.floor(scoreChange);
                    
                    // 2. Score VFX - Delayed
                    const scoreText = scoreChange >= 0 ? `+${scoreChange}` : `${scoreChange}`;
                    const scoreColor = scoreChange >= 0 ? 'text-emerald-400' : 'text-rose-500';
                    const scoreAnchor = document.getElementById('score-vfx-anchor').getBoundingClientRect();
                    spawnFloatingText(scoreText, scoreAnchor.left - 50, scoreAnchor.top + 20, scoreColor, 600);
                }

                document.getElementById('message-log').innerHTML = logMsg;

                // Handle HP Logic & Explosion
                this.enemyHP -= damage;

                if (this.isExplosive && isOverkill) {
                    this.triggerExplosion();
                    return; // Stop flow to handle explosion
                }

                this.updateGlobalUI(); // Triggers rolling counter
                this.updateHPUI();

                // Check Level End
                if (this.enemyHP <= 0.01) {
                     // Dead
                     if (this.mode === 'tutorial') {
                        setTimeout(() => this.advanceTutorial(), 1500);
                    } else {
                        setTimeout(() => {
                            this.levelInRound++;
                            this.nextLevel();
                        }, 1200);
                    }
                } else if (this.hand.length < 2 && this.enemyHP > 0.01) {
                     this.triggerGameOver("Ran out of cards");
                }
            }

            triggerExplosion() {
                // 1. Show Negative HP
                this.updateHPUI(true); // true = allow negative
                
                // 2. Animation Sequence
                setTimeout(() => {
                    const canvas = document.getElementById('graph-canvas');
                    canvas.parentElement.classList.add('explode-anim');
                    
                    // Prolonged Shake
                    this.shakeScreen(50, 1500);

                    // 3. Logic After Boom
                    setTimeout(() => {
                        canvas.parentElement.classList.remove('explode-anim');
                        
                        if (this.isBoss && this.currentBossTypes.includes('explosive')) {
                            this.triggerGameOver("EXPLOSIVE BOSS DETONATED");
                        } else {
                            // Regular Explosive Fail
                            this.roundScore = 0;
                            this.updateGlobalUI();
                            spawnFloatingText("SCORE RESET", window.innerWidth/2, window.innerHeight/2, 'text-rose-500 font-black', 0);
                            
                            // Move to next level anyway? Or retry? Usually roguelikes punish but let continue if not run-ending.
                            // Let's clear the level as "failed but survived"
                            this.levelInRound++;
                            this.nextLevel();
                        }
                    }, 800);
                }, 500);
            }

            // --- UI HELPERS ---

            updateGlobalUI() {
                // Rolling Counter for Score
                const scoreEl = document.getElementById('score-display');
                if (this.displayRoundScore !== this.roundScore) {
                    animateValue(scoreEl, this.displayRoundScore, this.roundScore, 1000);
                    this.displayRoundScore = this.roundScore;
                }
                
                document.getElementById('coins-display').innerText = this.coins;
                document.getElementById('mult-display').innerText = this.mult.toFixed(1);
                document.getElementById('round-display').innerText = this.round;
                const levelDisplay = document.getElementById('level-display');
                if (this.isBoss) { 
                    levelDisplay.innerText = `BOSS`;
                    levelDisplay.classList.remove(`text-slate-500`);
                    levelDisplay.classList.add(`text-rose-500`);
                }
                else {
                    levelDisplay.innerText = `${this.levelInRound}/${this.levelsPerRound}`;
                    if (levelDisplay.classList.contains('text-rose-500')) { levelDisplay.classList.replace(`text-rose-500`, `text-slate-500`); }
                }
            }

            updateHPUI(allowNegative = false) {
                const hpText = document.getElementById('hp-text');
                const hpBar = document.getElementById('hp-bar');
                
                // Text Display: Use mixed fraction if not integer
                let displayHP = this.enemyHP;
                if (!Number.isInteger(displayHP)) {
                    // Check if it's close to int
                    if (Math.abs(Math.round(displayHP) - displayHP) < 0.001) {
                         displayHP = Math.round(displayHP);
                    } else {
                         displayHP = toMixed(displayHP);
                    }
                } else {
                    displayHP = Math.ceil(displayHP); // Safety
                }
                
                // Allow negative text?
                if (!allowNegative && typeof displayHP === 'number' && displayHP < 0) displayHP = 0;
                
                hpText.innerText = `${displayHP}/${this.maxHP}`;

                // Bar Width
                let pct = (this.enemyHP / this.maxHP) * 100;
                if (!allowNegative) pct = Math.max(0, pct);
                if (pct < 0) pct = 0; 
                
                hpBar.style.width = `${pct}%`;
            }

            renderHand() {
                const c = document.getElementById('hand-container');
                c.innerHTML = '';
                this.hand.forEach(card => {
                    const el = document.createElement('div');
                    el.className = 'card shrink-0 w-20 h-28 bg-slate-100 rounded-lg shadow-lg flex flex-col items-center justify-center cursor-grab border-2 border-slate-300 relative overflow-y-visible';
                    el.draggable = true;
                    el.dataset.id = card.id; // Tag for hint finding
                    el.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', JSON.stringify(card)); el.classList.add('dragging'); });
                    el.addEventListener('dragend', () => el.classList.remove('dragging'));
                    el.innerHTML = `<div class="text-xs text-slate-400 font-bold absolute top-1 left-2">${card.value}</div><div class="text-4xl font-bold text-slate-800">${card.value}</div><div class="text-xs text-slate-400 font-bold absolute bottom-1 right-2">${card.value}</div>`;
                    c.appendChild(el);
                });
            }

            showTutorialPopup(title, body) {
                const modal = document.getElementById('tutorial-modal');
                document.getElementById('tutorial-title').innerText = title;
                document.getElementById('tutorial-body').innerHTML = body;
                modal.classList.remove('hidden');
                
                // Fix MathJax
                if (window.MathJax) {
                    MathJax.typesetPromise([document.getElementById('tutorial-body')]).catch((err) => console.log(err));
                }
            }

            toggleSettings() { document.getElementById('settings-modal').classList.toggle('hidden'); }
            toggleHints() { 
                this.hintsEnabled = !this.hintsEnabled; 
                document.getElementById('btn-hints').classList.toggle('bg-emerald-500'); 
                document.getElementById('hint-knob').classList.toggle('translate-x-6');
                document.getElementById('math-feedback').style.opacity = this.hintsEnabled ? 1 : 0;
                document.getElementById('hint-indicator').style.opacity = this.hintsEnabled ? 1 : 0;
                this.updatePreview();
            }

            triggerGameOver(reason) {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('death-reason').innerText = reason;
                document.getElementById('final-round').innerText = this.round;
                document.getElementById('final-coins').innerText = this.coins;
            }

            shakeScreen(intensity = 5, duration = 500) {
                const app = document.getElementById('app-scaler');
                app.style.animation = 'none';
                app.offsetHeight; 
                
                let start = Date.now();
                
                const shakeInterval = setInterval(() => {
                    let now = Date.now();
                    if (now - start > duration) {
                        clearInterval(shakeInterval);
                        app.style.transform = `scale(${this.getScale()})`; // Reset
                        return;
                    }
                    const dx = (Math.random() - 0.5) * intensity;
                    const dy = (Math.random() - 0.5) * intensity;
                    const baseScale = this.getScale();
                    app.style.transform = `scale(${baseScale}) translate(${dx}px, ${dy}px)`;
                }, 16);
            }

            getScale() {
                 return parseFloat(document.getElementById('app-scaler').style.transform.replace('scale(', '').replace(')', '')) || 1;
            }

            showTutorialMsg(msg) {
                const el = document.getElementById('tutorial-msg');
                el.innerText = msg;
                el.classList.add('animate-pulse');
            }

            // --- GRAPH RENDER ---
            renderGraph() {
                const w = this.canvas.width = this.canvas.clientWidth;
                const h = this.canvas.height = this.canvas.clientHeight;
                const ctx = this.ctx;

                ctx.clearRect(0, 0, w, h);

                // Camera Logic
                const scaleX = (w / 20) * this.pan.zoom; 
                const scaleY = scaleX; 
                const originX = w / 2 + this.pan.x;
                const originY = h / 2 + this.pan.y;

                // Grid
                ctx.strokeStyle = "#1e293b";
                ctx.lineWidth = 1;

                function calculateStep(graphZoom, baseStep = 1, sensitivity) {
                    if (baseStep / graphZoom <= 1) return 1 
                    let unroundedStep = Math.max(1, Math.floor((1.5 * baseStep) / graphZoom));
                    return roundToNiceNumber(unroundedStep);
                }

                function roundToNiceNumber(value) {
                    const magnitude = Math.floor(Math.log10(value));
                    const powerOf10 = Math.pow(10, magnitude);
                    const normalizedValue = value / powerOf10;
                    let niceFractional;
                    if (normalizedValue >= 5) niceFractional = 5;
                    else if (normalizedValue >= 2) niceFractional = 2;
                    else niceFractional = 1;
                    return niceFractional * powerOf10;
                }
                
                // Vertical Lines (X-axis)
                const xStep =  calculateStep(this.pan.zoom, 1);
                const numLinesX = Math.ceil((w / (scaleX * xStep)) / 2) * 2 + 1;
                const startX =  Math.ceil(0-numLinesX - this.pan.x / (scaleX * xStep));
                const endX = Math.floor(numLinesX - this.pan.x / (scaleX * xStep));
                for(let i=startX; i<endX; i++) {
                    const val = i * xStep;
                    const x = originX + val * scaleX;
                    if(x < 0 || x > w) continue;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                    if (i === 0) continue;
                    ctx.fillStyle = "#64748b"; ctx.font = "12px monospace"; ctx.fillText(val, x - 4, originY + 20);
                }
                
                // Horizontal Lines (Y-Axis)
                const yStep = calculateStep(this.pan.zoom, 1);
                const numLinesY = Math.ceil((h / (scaleY * yStep)) / 2) * 2 + 1;
                const startY =  Math.ceil(0-numLinesY + this.pan.y / (scaleY * yStep));
                const endY = Math.floor(numLinesY + this.pan.y / (scaleY * yStep));
                for(let i=startY; i<endY; i++) {
                    const val = i * yStep;
                    const y = originY - val * scaleY;
                    if(y < 0 || y > h) continue;
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                    if(i === 0) continue;
                    ctx.fillStyle = "#64748b"; ctx.font = "12px monospace"; ctx.fillText(val, originX - (8 + 6 * val.toString().length), y + 4);
                }

                // Draw Axes
                ctx.strokeStyle = "#94a3b8";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(originX, 0); ctx.lineTo(originX, h); // Y Axis
                ctx.moveTo(0, originY); ctx.lineTo(w, originY); // X Axis
                ctx.stroke();

                // Draw Function
                ctx.beginPath();
                ctx.strokeStyle = this.isExplosive ? "#fb7185" : "#38bdf8"; 
                ctx.lineWidth = 4;
                
                let startDraw = false;
                for(let px = 0; px < w; px+=2) { // Step optimization
                    const mathX = (px - originX) / scaleX;
                    const mathY = this.currentFunction.evaluate(mathX);
                    const py = originY - (mathY * scaleY);

                    // Clamp large values to prevent canvas rendering bugs
                    if (py < -1000 || py > h + 1000) {
                        startDraw = false;
                        continue;
                    }

                    if (!startDraw) {
                        ctx.moveTo(px, py);
                        startDraw = true;
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();

                // Draw Active Area
                if (this.slotA !== null && this.slotB !== null) {
                    const a = parseInt(this.slotA.value);
                    const b = parseInt(this.slotB.value);
                    
                    if (a < b) {
                        const startX = originX + a * scaleX;
                        const endX = originX + b * scaleX;

                        const grad = ctx.createLinearGradient(0, 0, 0, h);
                        grad.addColorStop(0, this.isExplosive ? "rgba(244, 63, 94, 0.5)" : "rgba(56, 189, 248, 0.5)"); 
                        grad.addColorStop(1, "rgba(244, 63, 94, 0.1)");

                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(startX, originY);

                        for(let px = startX; px <= endX; px++) {
                            const mathX = (px - originX) / scaleX;
                            const mathY = this.currentFunction.evaluate(mathX);
                            const py = originY - (mathY * scaleY);
                            ctx.lineTo(px, py);
                        }

                        ctx.lineTo(endX, originY);
                        ctx.closePath();
                        ctx.fill();

                        ctx.strokeStyle = this.isExplosive ? "#fb7185" : "#38bdf8";
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(startX, originY); ctx.lineTo(startX, originY - this.currentFunction.evaluate(a)*scaleY);
                        ctx.moveTo(endX, originY); ctx.lineTo(endX, originY - this.currentFunction.evaluate(b)*scaleY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }

            drawLoop() {
                if(!this.isDraggingGraph) { // Only auto-render if not dragging to save perf
                    this.renderGraph(); 
                }
                requestAnimationFrame(() => this.drawLoop());
            }
        }

        const game = new Game();
    </script>
</body>
</html>